use std::str::FromStr;
use parsing::ast::*;

grammar;

pub Prog: Program =
    <St*> => Program::Program(<>);

pub St: Statement = {
    EmptySt,
    BlockSt,
    ExprSt,
    VarDeclSt,
    IfSt,
};

EmptySt: Statement = ";" => Statement::EmptySt;

BlockSt: Statement = "{" <St*> "}" => Statement::BlockSt(<>);

ExprSt: Statement = <AssE> ";" => Statement::ExpressionSt(<>);

VarDeclSt: Statement = "var" <id:Identifier> "=" <val:AssE> ";" => Statement::VarDeclSt(id, val);

IfSt: Statement = {
    IfThenElse,
    IfThen,
};

IfThen: Statement = "if" "(" <cond:OrE> ")" <then_branch:St> "endif" =>
                                Statement::IfSt(cond, Box::new(then_branch), Option::None);


IfThenElse: Statement = "if" "(" <cond:OrE> ")" <then_branch:St> "else" <else_branch:St> "endif" =>
                                Statement::IfSt(cond, Box::new(then_branch), Option::Some(Box::new(else_branch)));


pub AssE: AssignmentExpr = {
    OrE => AssignmentExpr::UnaryAssignment(Box::new(<>)),
    <id:Identifier> "=" <r:OrE> => AssignmentExpr::BinaryAssignment(id, Box::new(r)),
};

pub OrE: LogicalOrExpr = {
    AndE => LogicalOrExpr::UnaryOr(Box::new(<>)),
    <l:OrE> "||" <r:AndE> => LogicalOrExpr::BinaryOr(Box::new(l), Box::new(r)),
};

pub AndE: LogicalAndExpr = {
    EqE => LogicalAndExpr::UnaryAnd(Box::new(<>)),
    <l:AndE> "&&" <r:EqE> => LogicalAndExpr::BinaryAnd(Box::new(l), Box::new(r)),
};

pub EqE: EqualityExpr = {
    AddE => EqualityExpr::UnaryEquality(Box::new(<>)),
    <l:EqE> "==" <r:AddE> => EqualityExpr::Equal(Box::new(l), Box::new(r)),
    <l:EqE> "!=" <r:AddE> => EqualityExpr::NotEqual(Box::new(l), Box::new(r)),
};

pub AddE: AdditiveExpr = {
    MultE => AdditiveExpr::UnaryAdditive(Box::new(<>)),
    <l:AddE> "+" <r:MultE> => AdditiveExpr::Plus(Box::new(l), Box::new(r)),
    <l:AddE> "-" <r:MultE> => AdditiveExpr::Minus(Box::new(l), Box::new(r)),
};

MultE: MultExpr = {
    Num => MultExpr::UnaryMult(<>),
    <l:MultE> "*" <r:Num> => MultExpr::Mult(Box::new(l), r),
    <l:MultE> "/" <r:Num> => MultExpr::Div(Box::new(l), r),
};

Num: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();

Identifier: String = r"[a-zA-Z][a-zA-Z0-9]*" => String::from_str(<>).unwrap();

