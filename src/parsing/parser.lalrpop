use std::str::FromStr;
use parsing::ast::*;

grammar;

pub Prog: Program =
    <SourceEl*> => Program::Program(<>);

pub SourceEl: SourceElement = {
    Stmt => SourceElement::StatementSE(<>),
    FuncDecl => SourceElement::FunctionDeclSE(<>),
};

pub FuncDecl: FunctionDeclaration = "function" <id:Identifier> "(" <params:IdentifiersList> ")" "{" <stmts:Stmt*> "}" => FunctionDeclaration::FunctionDeclaration(id, params, stmts);

pub Stmt: Statement = {
    EmptySt,
    BlockSt,
    ExprSt,
    VarDeclSt,
    IfSt,
};

EmptySt: Statement = ";" => Statement::EmptySt;

BlockSt: Statement = "{" <Stmt*> "}" => Statement::BlockSt(<>);

ExprSt: Statement = <AssE> ";" => Statement::ExpressionSt(<>);

VarDeclSt: Statement = "var" <id:Identifier> "=" <val:AssE> ";" => Statement::VarDeclSt(id, val);

IfSt: Statement = {
    IfThenElse,
    IfThen,
};

IfThen: Statement = "if" "(" <cond:OrE> ")" <then_branch:Stmt> "endif" =>
                                Statement::IfSt(cond, Box::new(then_branch), Option::None);


IfThenElse: Statement = "if" "(" <cond:OrE> ")" <then_branch:Stmt> "else" <else_branch:Stmt> "endif" =>
                                Statement::IfSt(cond, Box::new(then_branch), Option::Some(Box::new(else_branch)));


pub AssE: AssignmentExpr = {
    OrE => AssignmentExpr::UnaryAssignment(Box::new(<>)),
    <id:Identifier> "=" <r:OrE> => AssignmentExpr::BinaryAssignment(id, Box::new(r)),
};

pub OrE: LogicalOrExpr = {
    AndE => LogicalOrExpr::UnaryOr(Box::new(<>)),
    <l:OrE> "||" <r:AndE> => LogicalOrExpr::BinaryOr(Box::new(l), Box::new(r)),
};

pub AndE: LogicalAndExpr = {
    EqE => LogicalAndExpr::UnaryAnd(Box::new(<>)),
    <l:AndE> "&&" <r:EqE> => LogicalAndExpr::BinaryAnd(Box::new(l), Box::new(r)),
};

pub EqE: EqualityExpr = {
    AddE => EqualityExpr::UnaryEquality(Box::new(<>)),
    <l:EqE> "==" <r:AddE> => EqualityExpr::Equal(Box::new(l), Box::new(r)),
    <l:EqE> "!=" <r:AddE> => EqualityExpr::NotEqual(Box::new(l), Box::new(r)),
};

pub AddE: AdditiveExpr = {
    MultE => AdditiveExpr::UnaryAdditive(Box::new(<>)),
    <l:AddE> "+" <r:MultE> => AdditiveExpr::Plus(Box::new(l), Box::new(r)),
    <l:AddE> "-" <r:MultE> => AdditiveExpr::Minus(Box::new(l), Box::new(r)),
};

MultE: MultExpr = {
    AccessE => MultExpr::UnaryMult(Box::new(<>)),
    <l:MultE> "*" <r:AccessE> => MultExpr::Mult(Box::new(l), Box::new(r)),
    <l:MultE> "/" <r:AccessE> => MultExpr::Div(Box::new(l), Box::new(r)),
};

AccessE: AccessExpr = {
    Num => AccessExpr::NumberLiteral(<>),
    Identifier => AccessExpr::Identifier(<>),
    <id:Identifier> "(" <params:AssExprList> ")" => AccessExpr::Call(id, params),
};

AssExprList = Comma<AssE>;

Num: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();

Identifier: String = r"[a-zA-Z][a-zA-Z0-9]*" => String::from_str(<>).unwrap();

pub IdentifiersList = Comma<Identifier>;

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
